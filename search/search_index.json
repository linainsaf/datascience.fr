{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction \u00e0 la Data Science","text":""},{"location":"#cest-quoi-la-data-science","title":"C'est quoi la Data Science","text":"<p>La data science est un domaine qui s'int\u00e9resse \u00e0 l'extraction de connaissances \u00e0 partir de donn\u00e9es. Il utilise des techniques statistiques, math\u00e9matiques et informatiques pour analyser, interpr\u00e9ter et mod\u00e9liser des donn\u00e9es.</p> <p></p> <p></p> <p>La data science est utilis\u00e9e dans plusieurs domaines tels que la finance, la sant\u00e9, la vente au d\u00e9tail, le marketing, les transports et bien d'autres. C'est devenu de plus en plus important \u00e0 mesure que la quantit\u00e9 de donn\u00e9es g\u00e9n\u00e9r\u00e9es par la technologie moderne continue de cro\u00eetre.</p> <p></p> <p></p>"},{"location":"#les-differentes-etapes-dun-projet-de-data-science","title":"Les diff\u00e9rentes \u00e9tapes d'un projet de Data Science","text":""},{"location":"#collecte-de-donnees","title":"Collecte de donn\u00e9es","text":"<p>Le premier pas dans le processus de data science est de collecter des donn\u00e9es. Les donn\u00e9es peuvent provenir de diff\u00e9rentes sources telles que des fichiers, des bases de donn\u00e9es, des capteurs, des sondages, des enregistrements de transactions, des images, etc. Il est important de choisir des donn\u00e9es de qualit\u00e9 qui sont pertinentes pour le probl\u00e8me que vous souhaitez r\u00e9soudre.</p> <p></p> <p>Par exemple, pour pr\u00e9dire si un client d'une entreprise va acheter un produit, vous pouvez collecter des donn\u00e9es sur les achats pass\u00e9s, les pr\u00e9f\u00e9rences de produits, les habitudes de navigation en ligne, les interactions avec la marque sur les r\u00e9seaux sociaux, etc.</p>"},{"location":"#exploration-des-donnees","title":"Exploration des donn\u00e9es","text":"<p>Une fois les donn\u00e9es collect\u00e9es, il est important de les explorer pour comprendre leur nature, leur qualit\u00e9 et leur contenu. Cette \u00e9tape permet de d\u00e9tecter les valeurs manquantes, les donn\u00e9es aberrantes, les corr\u00e9lations, les distributions, etc. Cela peut se faire en utilisant des outils statistiques et graphiques.</p> <p></p> <p>Par exemple, pour comprendre les habitudes d'achat des clients, vous pouvez visualiser la distribution des prix d'achat, la corr\u00e9lation entre l'\u00e2ge et le montant d'achat, ou encore la fr\u00e9quence d'achat selon le canal de vente.</p>"},{"location":"#types-de-donnees","title":"Types de donn\u00e9es","text":"<p>Les donn\u00e9es sont le fondement de la data science, et elles peuvent \u00eatre de diff\u00e9rents types. Comprendre la nature des donn\u00e9es est important pour choisir les m\u00e9thodes d'analyse appropri\u00e9es.</p>"},{"location":"#donnees-numeriques","title":"Donn\u00e9es num\u00e9riques","text":"<p>Les donn\u00e9es num\u00e9riques sont des nombres, et peuvent \u00eatre continues ou discr\u00e8tes. Les donn\u00e9es continues peuvent prendre n'importe quelle valeur dans un intervalle donn\u00e9, tandis que les donn\u00e9es discr\u00e8tes sont limit\u00e9es \u00e0 des valeurs enti\u00e8res. Les donn\u00e9es num\u00e9riques peuvent \u00eatre utilis\u00e9es pour mesurer des grandeurs physiques, financi\u00e8res, ou pour quantifier des caract\u00e9ristiques. Exemples :</p> <ul> <li>La temp\u00e9rature en degr\u00e9s Celsius est une donn\u00e9e num\u00e9rique continue.</li> <li>Le nombre de produits vendus est une donn\u00e9e num\u00e9rique discr\u00e8te.</li> <li>Le montant d'une transaction financi\u00e8re est une donn\u00e9e num\u00e9rique continue.</li> </ul>"},{"location":"#donnees-categorielles","title":"Donn\u00e9es cat\u00e9gorielles","text":"<p>Les donn\u00e9es cat\u00e9gorielles sont des valeurs qui peuvent \u00eatre regroup\u00e9es en cat\u00e9gories. Elles peuvent \u00eatre nominales ou ordinales. Les donn\u00e9es cat\u00e9gorielles sont souvent utilis\u00e9es pour d\u00e9crire des caract\u00e9ristiques qualitatives. Exemples :</p> <ul> <li>La couleur des yeux est une donn\u00e9e cat\u00e9gorielle nominale.</li> <li>La taille des v\u00eatements est une donn\u00e9e cat\u00e9gorielle ordinale.</li> <li>La marque d'un produit est une donn\u00e9e cat\u00e9gorielle nominale.</li> </ul>"},{"location":"#donnees-temporelles","title":"Donn\u00e9es temporelles","text":"<p>Les donn\u00e9es temporelles sont des valeurs qui d\u00e9crivent des moments dans le temps. Elles peuvent \u00eatre des instants pr\u00e9cis, des p\u00e9riodes, ou des fr\u00e9quences. Les donn\u00e9es temporelles sont souvent utilis\u00e9es pour analyser des ph\u00e9nom\u00e8nes qui \u00e9voluent dans le temps. Exemples :</p> <ul> <li>La date de naissance est une donn\u00e9e temporelle de type instant.</li> <li>La dur\u00e9e d'une p\u00e9riode de vente est une donn\u00e9e temporelle de type p\u00e9riode.</li> <li>La fr\u00e9quence d'achat est une donn\u00e9e temporelle de type fr\u00e9quence.</li> </ul>"},{"location":"#donnees-textuelles","title":"Donn\u00e9es textuelles","text":"<p>Les donn\u00e9es textuelles sont des valeurs qui d\u00e9crivent du texte. Elles peuvent \u00eatre des phrases, des paragraphes, ou des documents entiers. Les donn\u00e9es textuelles sont souvent utilis\u00e9es pour analyser le langage naturel, ou pour extraire des informations de textes non structur\u00e9s. Exemples :</p> <ul> <li>Les avis des clients sur un produit sont des donn\u00e9es textuelles.</li> <li>Les descriptions des produits dans un catalogue sont des donn\u00e9es textuelles.</li> <li>Les articles de journaux sont des donn\u00e9es textuelles.</li> </ul>"},{"location":"#donnees-geospatiales","title":"Donn\u00e9es g\u00e9ospatiales","text":"<p>Les donn\u00e9es g\u00e9ospatiales sont des valeurs qui d\u00e9crivent des positions dans l'espace. Elles peuvent \u00eatre des coordonn\u00e9es g\u00e9ographiques, des adresses, ou des noms de lieux. Les donn\u00e9es g\u00e9ospatiales sont souvent utilis\u00e9es pour cartographier des donn\u00e9es, ou pour analyser des ph\u00e9nom\u00e8nes qui varient dans l'espace. Exemples :</p> <ul> <li>Les adresses des clients sont des donn\u00e9es g\u00e9ospatiales.</li> <li>Les coordonn\u00e9es GPS d'un point de vente sont des donn\u00e9es g\u00e9ospatiales.</li> <li>Les noms de villes dans un tableau de donn\u00e9es sont des donn\u00e9es g\u00e9ospatiales.</li> </ul>"},{"location":"#donnees-en-images","title":"Donn\u00e9es en images","text":"<p>Les donn\u00e9es en images sont des valeurs qui d\u00e9crivent des images. Elles sont souvent stock\u00e9es sous forme de pixels qui repr\u00e9sentent les couleurs ou les niveaux de gris des diff\u00e9rents points de l'image. Les donn\u00e9es en images sont souvent utilis\u00e9es dans des applications telles que la reconnaissance d'objets, la d\u00e9tection de fraudes et la surveillance. Exemples :</p> <ul> <li>Les images m\u00e9dicales sont des donn\u00e9es en images, comme les radiographies et les IRM.</li> <li>Les images satellites sont des donn\u00e9es en images qui peuvent \u00eatre utilis\u00e9es pour cartographier les zones g\u00e9ographiques et surveiller les changements dans les environnements naturels.</li> <li>Les images de surveillance de la circulation routi\u00e8re sont des donn\u00e9es en images qui peuvent \u00eatre utilis\u00e9es pour d\u00e9tecter les violations du code de la route.</li> </ul>"},{"location":"#donnees-en-audio","title":"Donn\u00e9es en audio","text":"<p>Les donn\u00e9es en audio sont des valeurs qui d\u00e9crivent des enregistrements sonores. Elles peuvent \u00eatre stock\u00e9es sous forme de signaux num\u00e9riques qui repr\u00e9sentent la fr\u00e9quence et l'amplitude du son \u00e0 diff\u00e9rents moments. Les donn\u00e9es en audio sont souvent utilis\u00e9es dans des applications telles que la reconnaissance vocale, la d\u00e9tection de fraudes et la surveillance. Exemples :</p> <ul> <li>Les enregistrements de voix sont des donn\u00e9es en audio qui peuvent \u00eatre utilis\u00e9es pour la reconnaissance vocale, telle que la conversion de la parole en texte.</li> <li>Les enregistrements de musique sont des donn\u00e9es en audio qui peuvent \u00eatre utilis\u00e9es pour la recommandation de musique et la classification de genres musicaux.</li> <li>Les enregistrements de surveillance audio sont des donn\u00e9es en audio qui peuvent \u00eatre utilis\u00e9es pour d\u00e9tecter les menaces et les comportements suspects.</li> </ul> <p>En tant que data scientist, il est important de comprendre les diff\u00e9rents types de donn\u00e9es, car cela peut avoir une incidence sur les m\u00e9thodes de collecte, de stockage, de traitement et d'analyse. En fonction des donn\u00e9es, les algorithmes de machine learning et les outils d'analyse peuvent varier consid\u00e9rablement.</p>"},{"location":"#selection-de-caracteristiques","title":"S\u00e9lection de caract\u00e9ristiques","text":"<p>Si le nombre de caract\u00e9ristiques est tr\u00e8s \u00e9lev\u00e9, il peut \u00eatre judicieux de s\u00e9lectionner les caract\u00e9ristiques les plus importantes pour am\u00e9liorer l'efficacit\u00e9 du mod\u00e8le.</p>"},{"location":"#separation-des-donnees","title":"S\u00e9paration des donn\u00e9es","text":"<p>Les donn\u00e9es doivent \u00eatre divis\u00e9es en deux parties, l'ensemble d'entra\u00eenement et l'ensemble de test. L'ensemble d'entra\u00eenement est utilis\u00e9 pour entra\u00eener le mod\u00e8le et l'ensemble de test est utilis\u00e9 pour \u00e9valuer les performances du mod\u00e8le.</p>"},{"location":"#construction-de-notre-modele-ia","title":"Construction de notre mod\u00e8le (IA)","text":"<p>Une fois les donn\u00e9es nettoy\u00e9es et pr\u00e9trait\u00e9es, il est temps de choisir un mod\u00e8le d'IA et de l'entra\u00eener sur l'ensemble d'entra\u00eenement. Le choix du mod\u00e8le d\u00e9pend du type de probl\u00e8me \u00e0 r\u00e9soudre et du type de donn\u00e9es.</p> <p></p> <p>L'intelligence artificielle (IA) est un domaine de l'informatique qui vise \u00e0 cr\u00e9er des machines capables de r\u00e9aliser des t\u00e2ches qui n\u00e9cessitent normalement l'intelligence humaine. Cette discipline est bas\u00e9e sur le d\u00e9veloppement de programmes informatiques qui peuvent apprendre et s'adapter \u00e0 de nouvelles situations, et ainsi ex\u00e9cuter des t\u00e2ches sans intervention humaine.</p> <p></p> <p>Il existe plusieurs modes d'apprentissage :</p> <ul> <li> <p>Le Machine Learning (apprentissage automatique en fran\u00e7ais) est une branche de l'intelligence artificielle qui se concentre sur l'apprentissage de mod\u00e8les \u00e0 partir de donn\u00e9es, afin de r\u00e9aliser des t\u00e2ches de pr\u00e9diction ou de classification. Les mod\u00e8les peuvent \u00eatre entra\u00een\u00e9s \u00e0 l'aide de diff\u00e9rentes techniques, notamment l'apprentissage supervis\u00e9 (o\u00f9 les donn\u00e9es sont \u00e9tiquet\u00e9es pour indiquer la r\u00e9ponse souhait\u00e9e) et l'apprentissage non supervis\u00e9 (o\u00f9 les donn\u00e9es ne sont pas \u00e9tiquet\u00e9es). Le Machine Learning est utilis\u00e9 dans de nombreux domaines, notamment la reconnaissance vocale, la reconnaissance d'images, la recommandation de produits et la d\u00e9tection de fraudes.</p> </li> <li> <p>Le Reinforcement Learning (apprentissage par renforcement en fran\u00e7ais) est une branche sp\u00e9cifique du Machine Learning qui se concentre sur l'apprentissage par essais et erreurs. Dans ce type d'apprentissage, un agent est plac\u00e9 dans un environnement et doit apprendre \u00e0 prendre des d\u00e9cisions pour maximiser une r\u00e9compense. L'agent prend une action, re\u00e7oit une r\u00e9compense ou une p\u00e9nalit\u00e9, et utilise cette information pour ajuster sa strat\u00e9gie. Le Reinforcement Learning est utilis\u00e9 pour des applications comme les jeux vid\u00e9o, les robots, et les syst\u00e8mes de recommandation personnalis\u00e9e.</p> </li> <li> <p>Le Deep Learning (apprentissage profond en fran\u00e7ais) est une sous-branche du Machine Learning qui utilise des r\u00e9seaux de neurones artificiels pour apprendre \u00e0 partir de donn\u00e9es. Les r\u00e9seaux de neurones artificiels sont des mod\u00e8les computationnels qui sont con\u00e7us pour imiter le fonctionnement du cerveau humain. Les r\u00e9seaux de neurones sont compos\u00e9s de plusieurs couches, chacune traitant une partie de l'information en entr\u00e9e pour produire une sortie. Le Deep Learning est utilis\u00e9 dans de nombreux domaines, notamment la reconnaissance vocale, la reconnaissance d'images, la traduction automatique et la reconnaissance de caract\u00e8res manuscrits.</p> </li> </ul>"},{"location":"#evaluation-du-modele","title":"\u00c9valuation du mod\u00e8le","text":"<p>Apr\u00e8s l'entra\u00eenement du mod\u00e8le, il est important d'\u00e9valuer sa performance sur l'ensemble de test. Il existe de nombreuses mesures pour \u00e9valuer les performances d'un mod\u00e8le, telles que l'exactitude, la pr\u00e9cision, le rappel et le F1-score.</p>"},{"location":"#optimisation-du-modele","title":"Optimisation du mod\u00e8le","text":"<p>Si les performances du mod\u00e8le ne sont pas satisfaisantes, il peut \u00eatre n\u00e9cessaire de le r\u00e9ajuster ou de r\u00e9gler ses param\u00e8tres pour am\u00e9liorer ses performances.</p>"},{"location":"#deploiement-du-modele","title":"D\u00e9ploiement du mod\u00e8le","text":"<p>Une fois que le mod\u00e8le a \u00e9t\u00e9 entra\u00een\u00e9 et \u00e9valu\u00e9 avec succ\u00e8s, il peut \u00eatre d\u00e9ploy\u00e9 dans un environnement de production. Cela peut inclure l'int\u00e9gration du mod\u00e8le dans une application ou un syst\u00e8me existant.</p>"},{"location":"dl/","title":"Introduction au Deep Learning","text":""},{"location":"dl/#cest-quoi-le-deep-learning","title":"C'est quoi le Deep Learning","text":"<p>Le Deep Learning est une sous-branche du Machine Learning qui utilise des r\u00e9seaux de neurones profonds pour apprendre des repr\u00e9sentations hi\u00e9rarchiques de donn\u00e9es complexes. Contrairement au Machine Learning classique, qui se concentre sur l'extraction de caract\u00e9ristiques manuellement con\u00e7ues \u00e0 partir de donn\u00e9es, le Deep Learning permet aux mod\u00e8les d'apprendre automatiquement \u00e0 partir de donn\u00e9es brutes sans la n\u00e9cessit\u00e9 d'ing\u00e9nierie de caract\u00e9ristiques.</p> <p></p> <p>Les avantages du Deep Learning incluent :</p> <ul> <li>Performance am\u00e9lior\u00e9e : Les mod\u00e8les de Deep Learning peuvent apprendre \u00e0 partir de donn\u00e9es brutes et trouver des caract\u00e9ristiques importantes pour une t\u00e2che donn\u00e9e, ce qui peut conduire \u00e0 des performances am\u00e9lior\u00e9es sur une grande vari\u00e9t\u00e9 de t\u00e2ches, y compris la vision par ordinateur, la reconnaissance vocale et le traitement du langage naturel.</li> <li>Scalabilit\u00e9 : Les r\u00e9seaux de neurones profonds peuvent \u00eatre con\u00e7us pour traiter des donn\u00e9es massives et peuvent \u00eatre utilis\u00e9s dans des environnements distribu\u00e9s pour am\u00e9liorer encore les performances.</li> <li>Adaptabilit\u00e9 : Les mod\u00e8les de Deep Learning peuvent \u00eatre adapt\u00e9s \u00e0 de nouveaux jeux de donn\u00e9es sans avoir besoin de modifications majeures de l'architecture du mod\u00e8le, ce qui les rend plus flexibles et adaptables que les mod\u00e8les de Machine Learning classiques.</li> </ul> <p>Cependant, le Deep Learning pr\u00e9sente \u00e9galement quelques inconv\u00e9nients, notamment :</p> <ul> <li> <p>Co\u00fbt en ressources : L'entra\u00eenement de mod\u00e8les de Deep Learning peut \u00eatre tr\u00e8s co\u00fbteux en temps et en ressources informatiques, en particulier pour des jeux de donn\u00e9es massifs. L'inf\u00e9rence peut \u00e9galement \u00eatre co\u00fbteuse, en particulier sur des dispositifs mobiles ou des syst\u00e8mes embarqu\u00e9s.</p> </li> <li> <p>Manque de transparence : Les mod\u00e8les de Deep Learning peuvent \u00eatre difficiles \u00e0 interpr\u00e9ter, car ils sont souvent con\u00e7us avec des couches cach\u00e9es qui rendent difficile la compr\u00e9hension de la mani\u00e8re dont le mod\u00e8le prend des d\u00e9cisions. Cela peut rendre le d\u00e9beugage et le d\u00e9pannage plus difficiles.</p> </li> <li> <p>Besoin de donn\u00e9es de haute qualit\u00e9 : Les mod\u00e8les de Deep Learning n\u00e9cessitent souvent des ensembles de donn\u00e9es massifs et de haute qualit\u00e9 pour obtenir des performances optimales. Cela peut rendre l'entra\u00eenement de mod\u00e8les de Deep Learning difficile pour les domaines o\u00f9 les donn\u00e9es sont rares ou co\u00fbteuses \u00e0 collecter.</p> </li> </ul>"},{"location":"dl/#cest-quoi-un-neurone","title":"C'est quoi un Neurone","text":"<p>Un neurone est la plus petite unit\u00e9 de traitement dans un r\u00e9seau de neurones. Il re\u00e7oit des entr\u00e9es pond\u00e9r\u00e9es, les somme et les passe \u00e0 travers une fonction d'activation non-lin\u00e9aire pour produire une sortie. Les poids sont des param\u00e8tres qui sont ajust\u00e9s par le mod\u00e8le pendant l'apprentissage pour minimiser une fonction de co\u00fbt.</p> <p></p>"},{"location":"dl/#cest-quoi-les-couches-de-neurones","title":"C'est quoi les couches de Neurones","text":"<p>Pour un probl\u00e8me non lin\u00e9aire ou utilise des couches. Une couche de neurones est un groupe de neurones qui traitent simultan\u00e9ment les entr\u00e9es qu'ils re\u00e7oivent. Les couches de neurones sont g\u00e9n\u00e9ralement organis\u00e9es en s\u00e9quences, avec chaque couche prenant en entr\u00e9e les sorties de la couche pr\u00e9c\u00e9dente. On peut distingue distinguer deux blocs de couches : </p> <ul> <li>Une ou plusieurs couches cach\u00e9es compos\u00e9es de plusieurs neurones</li> <li>Une couche de sortie compos\u00e9e de K neurones \\(y = [y_1, ...,y_k]\\)</li> </ul> <p></p> <ul> <li> <p>En r\u00e9gression: Sortie continue/un seule neurone =&gt; la derni\u00e9re couche a une fonction d'activation lin\u00e9aire</p> </li> <li> <p>En classification: La derniere couche a K neurones (K = Nombre de classes) =&gt; La derni\u00e8re couche a une fonction d'activation softmax qui transforme la sortie du r\u00e9seau en probabilit\u00e9s d'appartenance aux classes.</p> </li> </ul>"},{"location":"dl/#cest-quoi-les-fonctions-dactivation","title":"C'est quoi les fonctions d'activation","text":"<p>Une fonction d\u2019activation est une fonction math\u00e9matique utilis\u00e9 sur un signal. Elle va reproduire le potentiel d\u2019activation que l\u2019on retrouve dans le domaine de la biologie du cerveau humain. Elle va permettre le passage d\u2019information ou non de l\u2019information si le seuil de stimulation est atteint. Concr\u00e8tement, elle va avoir pour r\u00f4le de d\u00e9cider si on active ou non une r\u00e9ponse du neurone. Voici les principales fonctions d\u2019activations que l\u2019on peut trouver dans des r\u00e9seaux de neurones :</p> <ul> <li> <p>Linear: Utilis\u00e9 en couche de sortie pour une utilisation pour une r\u00e9gression. On peut la caract\u00e9riser de nulle, puisque les unit\u00e9s de sortie seront identiques \u00e0 leur niveau d\u2019entr\u00e9. Intervalle de sortie (-\u221e;+\u221e).</p> </li> <li> <p>Sigmoid (logistic) : Fonction la plus populaire depuis des d\u00e9cennies. Mais aujourd\u2019hui, elle devient beaucoup moins efficace par rapport \u00e0 d\u2019autre pour une utilisation pour les couches cach\u00e9es. Utilis\u00e9 en couche de sortie pour de la classification binaire. Intervalle de sortie : {0,1}</p> </li> <li> <p>TanH : Utilis\u00e9 pour des RNN pour des donn\u00e9es en continue. Intervalle de sortie : (-1,1)</p> </li> <li> <p>Softmax : Utilis\u00e9 pour de la multi classification en couche de sortie. Intervalle de sortie (-\u221e;+\u221e).</p> </li> <li> <p>ReLU ( Rectified Linear Unit ) : Ce sont les fonctions les plus populaires de nos jours. Elles permettent un entrainement plus rapide compar\u00e9 aux fonctions sigmoid et tanh, \u00e9tant plus l\u00e9g\u00e8res. Attention au ph\u00e9nom\u00e8ne de \u2018Dying ReLU\u2019, auquel on pr\u00e9f\u00e9rera les variations de ReLU. Tr\u00e8s utilis\u00e9 pour les CNN, RBM, et les r\u00e9seaux de multi perceptron. Intervalle de sortie (0;+\u221e).</p> </li> <li> <p>Leaky ReLU : La Leakey Relu permet d\u2019ajouter une variante pour les nombres n\u00e9gatifs, ainsi les neurones ne meurent jamais. Ils entrent dans un long coma mais on toujours la chance de se r\u00e9veiller \u00e0 un moment donn\u00e9. Intervalle de sortie (-\u221e;+\u221e).</p> </li> </ul> <p></p>"},{"location":"dl/#cest-quoi-la-backpropagation-comment-un-reseau-sentraine","title":"C'est quoi la backpropagation (Comment un r\u00e9seau s'entraine)","text":"<p>La r\u00e9tropropagation (backpropagation en anglais) est l'algorithme d'optimisation utilis\u00e9 pour entra\u00eener les r\u00e9seaux de neurones. Il s'agit d'une m\u00e9thode de calcul de gradient qui permet de calculer les gradients de l'erreur par rapport aux poids de chaque neurone dans le r\u00e9seau, en utilisant la r\u00e8gle de la cha\u00eene.</p> <p></p> <p>Le processus de r\u00e9tropropagation commence par une \u00e9tape de propagation avant (forward pass) dans laquelle les entr\u00e9es sont pr\u00e9sent\u00e9es au r\u00e9seau et les pr\u00e9dictions sont calcul\u00e9es en passant successivement \u00e0 travers chaque couche du r\u00e9seau.</p> <p></p> <p>Ensuite, l'erreur de pr\u00e9diction est calcul\u00e9e en comparant les pr\u00e9dictions du r\u00e9seau aux valeurs r\u00e9elles de sortie. L'objectif de l'apprentissage est de minimiser cette erreur.</p> <p></p> <p>\u00c0 partir de l'erreur de pr\u00e9diction, la r\u00e9tropropagation calcule le gradient de l'erreur par rapport \u00e0 chaque poids dans le r\u00e9seau, en utilisant la r\u00e8gle de la cha\u00eene pour calculer les gradients \u00e0 travers les couches du r\u00e9seau en partant de la derni\u00e8re couche vers la premi\u00e8re.</p> <p></p> <p>Une fois que les gradients ont \u00e9t\u00e9 calcul\u00e9s, ils peuvent \u00eatre utilis\u00e9s pour ajuster les poids dans le r\u00e9seau en utilisant une m\u00e9thode d'optimisation telle que la descente de gradient stochastique (SGD en anglais).</p> <p></p> <p>L'ensemble du processus de r\u00e9tropropagation est r\u00e9p\u00e9t\u00e9 de nombreuses fois, en pr\u00e9sentant diff\u00e9rentes donn\u00e9es d'entra\u00eenement au r\u00e9seau \u00e0 chaque it\u00e9ration, jusqu'\u00e0 ce que le r\u00e9seau converge vers une solution qui minimise l'erreur de pr\u00e9diction moyenne sur l'ensemble des donn\u00e9es d'entra\u00eenement.</p> <p></p> <p>Terminologie : </p> <ul> <li>Batch : sous ensemble de la base train</li> <li>Epoch : nombre de fois que tous les exemples sont vus en apprentissage</li> <li>It\u00e9ration : nombre de batchs vus en apprentissage</li> </ul>"},{"location":"dl/#comprendre-loverfitting-et-underfitting","title":"Comprendre l'overfitting et underfitting","text":"<p>On souhaite avoir un r\u00e9seau qui puisse effectuer des pr\u00e9dictions sur de nouvelles donn\u00e9es. Selon la fa\u00e7on dont est entrain\u00e9 le model, on peut se heurter \u00e0 2 probl\u00e8mes :</p> <ul> <li> <p>Sur apprentissage : Cela repr\u00e9sente un mod\u00e8le qui a appris par c\u0153ur ses donn\u00e9es d\u2019entrainement, qui fonctionne donc bien sur le jeu d\u2019entrainement mais pas de validation. Il effectue alors de mauvaise pr\u00e9diction sur de nouvelles, car elles ne sont pas exactement les m\u00eames que celle du jeu d\u2019entrainement. Pour y rem\u00e9dier, il faut am\u00e9liorer la flexibilit\u00e9 du mod\u00e8le, et donc jouer sur des concept de r\u00e9gularisation par exemple, ou encore d\u2019early stopping.</p> </li> <li> <p>Sous apprentissage : Ce cas-ci repr\u00e9sente un mod\u00e8le qui n\u2019arrive pas \u00e0 d\u00e9duire des informations du jeu de donn\u00e9es. Il n\u2019apprend donc pas assez et r\u00e9alise de mauvaise pr\u00e9diction sur le jeu d\u2019entrainement. Il faut donc complexifier le r\u00e9seau, car il ne taille pas bien par rapport aux types de donn\u00e9es d\u2019entr\u00e9es. En effet, il n\u2019arrive pas \u00e0 capter la relation entre les donn\u00e9es d\u2019entr\u00e9es et leur label.</p> </li> </ul> <p></p> <p>Dans le cas o\u00f9 la pr\u00e9cision du r\u00e9seau n\u2019est ni bonne sur le jeu d\u2019entrainement, ni sur celui de validation, c\u2019est que le r\u00e9seau n\u2019a pas eu assez de temps pour apprendre des donn\u00e9es. Il faut donc augmenter le nombre d\u2019it\u00e9ration, ou augmenter la taille du jeu de donn\u00e9e.</p>"},{"location":"dl/#regularisation-du-reseau-avec-les-dropout","title":"R\u00e9gularisation du r\u00e9seau avec les Dropout","text":"<p>Le Dropout est une technique de r\u00e9gularisation utilis\u00e9e pour r\u00e9duire le surapprentissage dans les r\u00e9seaux de neurones profonds. On va souhaiter favoriser l\u2019extraction de caract\u00e9ristique de fa\u00e7on ind\u00e9pendante, afin d\u2019apprendre des caract\u00e9ristique plus g\u00e9n\u00e9ral et plus diverse. Cela va consister \u00e0 \u2018\u00e9teindre\u2019, \u00e0 d\u00e9sactiver certains neurones du mod\u00e8le, et ce de fa\u00e7on al\u00e9atoire d\u2019une m\u00eame couche, qui ne contribuera donc ni \u00e0 la phase de feedforward, ni \u00e0 la phase de backpropagation. D\u2019un point de vue du r\u00e9seau, cela revient \u00e0 instancier la valeur en sortie d\u2019une fonction d\u2019activation \u00e0 0</p> <p></p>"},{"location":"dltypes/","title":"Les diff\u00e9rents types de r\u00e9seaux de neurones","text":"<p>Il existe diff\u00e9rents types de r\u00e9seaux de neurones, chacune ayant sa propre fonction et sa propre m\u00e9thode de traitement des donn\u00e9es d'entr\u00e9e. Voici un aper\u00e7u de quelques types courants de couches de neurones :</p>"},{"location":"dltypes/#les-reseaux-de-neurones-denses-fully-connected-layers","title":"Les r\u00e9seaux de neurones denses (Fully Connected Layers)","text":"<p>Un r\u00e9seau de neurones dense, \u00e9galement appel\u00e9 r\u00e9seau de neurones \u00e0 couches enti\u00e8rement connect\u00e9es, est un type de r\u00e9seau de neurones o\u00f9 chaque neurone dans une couche est connect\u00e9 \u00e0 tous les neurones de la couche pr\u00e9c\u00e9dente et de la couche suivante. Cela signifie que chaque neurone de la couche actuelle prend en compte toutes les activations de la couche pr\u00e9c\u00e9dente et renvoie une activation qui est propag\u00e9e \u00e0 tous les neurones de la couche suivante.</p> <p></p> <p></p> <p></p> <p>La sortie d'une couche dense est calcul\u00e9e comme suit :</p> \\[y_j = f\\left(\\sum_{i=1}^n w_{ji}x_i + b_j\\right)\\] <p>o\u00f9 :</p> <ul> <li>\\(y_j\\) est la sortie du \\(j\\)-\u00e8me neurone de la couche dense.</li> <li>\\(x_i\\) est l'activation du \\(i\\)-\u00e8me neurone de la couche pr\u00e9c\u00e9dente.</li> <li>\\(w_{ji}\\) est le poids de la connexion entre le \\(i\\)-\u00e8me neurone de la couche pr\u00e9c\u00e9dente et le \\(j\\)-\u00e8me neurone de la couche dense.</li> <li>\\(b_j\\) est le biais (un param\u00e8tre suppl\u00e9mentaire) du \\(j\\)-\u00e8me neurone de la couche dense.</li> <li>\\(f\\) est la fonction d'activation appliqu\u00e9e \u00e0 la somme pond\u00e9r\u00e9e des entr\u00e9es.</li> <li>La fonction d'activation \\(f\\) peut \u00eatre choisie en fonction du probl\u00e8me \u00e0 r\u00e9soudre.</li> </ul>"},{"location":"dltypes/#les-reseaux-de-neurones-convolutifs-convolutional-neural-networks","title":"Les r\u00e9seaux de neurones convolutifs (Convolutional Neural Networks)","text":"<p>Les r\u00e9seaux de neurones convolutifs (Convolutional Neural Networks ou CNNs) sont un type de r\u00e9seau de neurones sp\u00e9cialement con\u00e7us pour le traitement des images. Ils ont \u00e9t\u00e9 introduits pour la premi\u00e8re fois par Yann LeCun et ses coll\u00e8gues en 1998 pour la reconnaissance de caract\u00e8res manuscrits.</p> <p></p> <p>Les CNNs sont bas\u00e9s sur des filtres de convolution, qui sont des matrices de poids qui sont appliqu\u00e9es \u00e0 des r\u00e9gions de l'image. Les filtres de convolution permettent d'extraire des caract\u00e9ristiques visuelles \u00e0 diff\u00e9rentes \u00e9chelles. Par exemple, un filtre de convolution peut \u00eatre con\u00e7u pour d\u00e9tecter les bords dans une image, tandis qu'un autre filtre peut \u00eatre con\u00e7u pour d\u00e9tecter les coins.</p> <p></p> <p>Un r\u00e9seau de neurones convolutif se compose de plusieurs couches. La premi\u00e8re couche est la couche d'entr\u00e9e, qui contient l'image brute. Les couches suivantes sont des couches de convolution, qui appliquent des filtres de convolution \u00e0 l'image. Chaque filtre de convolution produit une carte de caract\u00e9ristiques, qui est une image qui met en \u00e9vidence les caract\u00e9ristiques sp\u00e9cifiques d\u00e9tect\u00e9es par le filtre. Les cartes de caract\u00e9ristiques sont ensuite pass\u00e9es \u00e0 une fonction d'activation, qui introduit une non-lin\u00e9arit\u00e9 dans le mod\u00e8le.</p> <p></p> <p>Apr\u00e8s les couches de convolution, il y a g\u00e9n\u00e9ralement des couches de regroupement (pooling layers), qui r\u00e9duisent la dimensionnalit\u00e9 de l'image en prenant le maximum, la moyenne ou la somme de petites r\u00e9gions de l'image. Les couches de regroupement permettent de r\u00e9duire le temps de calcul et de rendre le mod\u00e8le plus robuste aux variations mineures dans l'image.</p> <p></p> <p>Apr\u00e8s les couches de regroupement, il y a g\u00e9n\u00e9ralement des couches enti\u00e8rement connect\u00e9es (Fully Connected Layers), qui sont similaires aux couches de neurones denses des r\u00e9seaux de neurones classiques. Les couches enti\u00e8rement connect\u00e9es prennent les cartes de caract\u00e9ristiques en entr\u00e9e et les transforment en une repr\u00e9sentation de sortie qui est utilis\u00e9e pour la classification ou la r\u00e9gression.</p> <p></p> <p>Les CNNs sont entra\u00een\u00e9s \u00e0 l'aide d'un algorithme d'optimisation, tel que la descente de gradient stochastique (Stochastic Gradient Descent), pour minimiser une fonction de perte (loss function) qui mesure la diff\u00e9rence entre la sortie pr\u00e9dite et la sortie r\u00e9elle. Pendant l'entra\u00eenement, les poids des filtres de convolution et des couches enti\u00e8rement connect\u00e9es sont ajust\u00e9s pour minimiser la fonction de perte.</p> <p></p> <p></p> <p></p> <p>L'\u00e9quation pour la sortie d'une couche de convolution:</p> \\[y(i,j,k) = \\text{activation}\\left(\\sum_{l=1}^{p}\\sum_{m=1}^{q}\\sum_{n=1}^{r} w(m,n,l,k) x(i+m-1,j+n-1,l)\\right)\\] <p>o\u00f9 :</p> <ul> <li>\\(y(i,j,k)\\) est la sortie du \\(k\\)-\u00e8me filtre \u00e0 la position \\((i,j)\\) dans la carte de caract\u00e9ristiques de sortie.</li> <li>\\(\\text{activation}\\) est la fonction d'activation appliqu\u00e9e \u00e9l\u00e9ment par \u00e9l\u00e9ment \u00e0 la somme des entr\u00e9es pond\u00e9r\u00e9es.</li> <li>\\(w(m,n,l,k)\\) est le poids du \\(k\\)-\u00e8me filtre \u00e0 la position \\((m,n)\\) dans le \\(l\\)-\u00e8me canal d'entr\u00e9e.</li> <li>\\(x(i+m-1,j+n-1,l)\\) est l'activation d'entr\u00e9e \u00e0 la position \\((i+m-1,j+n-1)\\) dans le \\(l\\)-\u00e8me canal d'entr\u00e9e.</li> <li>\\(p,q,r\\) sont les dimensions du filtre.</li> </ul>"},{"location":"dltypes/#les-reseaux-de-neurones-recurrents-recurrent-neural-networks","title":"Les r\u00e9seaux de neurones r\u00e9currents (Recurrent Neural Networks)","text":"<p>Un r\u00e9seau de neurones r\u00e9currents (RNN) est un type de r\u00e9seau de neurones qui est capable de traiter des s\u00e9quences de donn\u00e9es en utilisant la r\u00e9troaction (feedback) des sorties pr\u00e9c\u00e9dentes comme entr\u00e9e pour les calculs futurs. Contrairement aux r\u00e9seaux de neurones classiques, les RNN ont des connexions de neurones cycliques, ce qui leur permet de stocker une m\u00e9moire interne de l'information trait\u00e9e jusqu'\u00e0 pr\u00e9sent.</p> <p></p> <p>Un RNN peut \u00eatre repr\u00e9sent\u00e9 comme une s\u00e9quence de cellules, o\u00f9 chaque cellule est une copie du m\u00eame r\u00e9seau de neurones. Chaque cellule prend en entr\u00e9e les donn\u00e9es de la s\u00e9quence et l'\u00e9tat cach\u00e9 de la cellule pr\u00e9c\u00e9dente. L'\u00e9tat cach\u00e9 est une repr\u00e9sentation vectorielle de la m\u00e9moire interne de la cellule, qui est mise \u00e0 jour \u00e0 chaque \u00e9tape de la s\u00e9quence.</p> <p></p> <p>La sortie de chaque cellule est renvoy\u00e9e \u00e0 la cellule suivante et est \u00e9galement utilis\u00e9e pour la pr\u00e9diction finale. La pr\u00e9diction finale est donc bas\u00e9e sur l'ensemble des sorties de toutes les cellules de la s\u00e9quence.</p> <p></p> <p></p> <p></p> <p>La sortie d'une cellule RNN est calcul\u00e9e comme suit :</p> \\[ h_t = f(W_{xh}x_t + W_{hh}h_{t-1} + b_h) \\] <p>o\u00f9 :</p> <ul> <li>\\(h_t\\) est l'\u00e9tat cach\u00e9 de la cellule \u00e0 l'\u00e9tape \\(t\\).</li> <li>\\(x_t\\) est l'entr\u00e9e \u00e0 l'\u00e9tape \\(t\\).</li> <li>\\(W_{xh}\\) est la matrice de poids pour les connexions entre les entr\u00e9es et l'\u00e9tat cach\u00e9.</li> <li>\\(W_{hh}\\) est la matrice de poids pour les connexions entre l'\u00e9tat cach\u00e9 de l'\u00e9tape pr\u00e9c\u00e9dente et l'\u00e9tat cach\u00e9 actuel.</li> <li>\\(b_h\\) est le biais ajout\u00e9 \u00e0 l'\u00e9tat cach\u00e9.</li> <li>\\(f\\) est la fonction d'activation appliqu\u00e9e \u00e0 la somme pond\u00e9r\u00e9e des entr\u00e9es.</li> </ul> <p>La sortie de la cellule peut \u00e9galement \u00eatre utilis\u00e9e pour pr\u00e9dire la prochaine valeur de la s\u00e9quence :</p> \\[ y_t = g(W_{hy}h_t + b_y) \\] <p>o\u00f9 :</p> <ul> <li>\\(y_t\\) est la pr\u00e9diction de la valeur de la s\u00e9quence \u00e0 l'\u00e9tape \\(t\\).</li> <li>\\(W_{hy}\\) est la matrice de poids pour les connexions entre l'\u00e9tat cach\u00e9 et la pr\u00e9diction.</li> <li>\\(b_y\\) est le biais ajout\u00e9 \u00e0 la pr\u00e9diction.</li> <li>\\(g\\) est la fonction d'activation appliqu\u00e9e \u00e0 la somme pond\u00e9r\u00e9e des entr\u00e9es.</li> </ul> <p>Les RNN sont largement utilis\u00e9s pour la mod\u00e9lisation de s\u00e9quences, notamment pour la reconnaissance de la parole, la traduction automatique et la g\u00e9n\u00e9ration de texte.</p>"},{"location":"dltypes/#les-reseaux-de-neurones-de-memoire-a-court-terme-long-short-term-memory-networks","title":"Les r\u00e9seaux de neurones de m\u00e9moire \u00e0 court terme (Long Short-Term Memory Networks)","text":"<p>Ce sont des r\u00e9seaux de neurones r\u00e9currents am\u00e9lior\u00e9s qui permettent de traiter des s\u00e9quences de donn\u00e9es plus longues. Les r\u00e9seaux de neurones de m\u00e9moire \u00e0 court terme utilisent des unit\u00e9s de m\u00e9moire qui leur permettent de retenir l'information importante sur une longue p\u00e9riode de temps, et sont utilis\u00e9s pour la g\u00e9n\u00e9ration de texte, la pr\u00e9diction de la prochaine valeur dans une s\u00e9rie temporelle, etc.</p>"},{"location":"dltypes/#les-reseaux-de-neurones-auto-encodeurs-autoencoder-neural-networks","title":"Les r\u00e9seaux de neurones auto-encodeurs (Autoencoder Neural Networks)","text":"<p>Ce sont des r\u00e9seaux de neurones qui apprennent \u00e0 reconstruire une entr\u00e9e \u00e0 partir d'une repr\u00e9sentation latente, en comprimant l'information dans une couche cach\u00e9e de neurones. Les r\u00e9seaux de neurones auto-encodeurs sont utilis\u00e9s pour la compression de donn\u00e9es, la d\u00e9tection d'anomalies, etc.</p>"},{"location":"dltypes/#les-reseaux-de-neurones-generatifs-generative-neural-networks","title":"Les r\u00e9seaux de neurones g\u00e9n\u00e9ratifs (Generative Neural Networks)","text":"<p>Ce sont des r\u00e9seaux de neurones qui apprennent \u00e0 g\u00e9n\u00e9rer de nouvelles donn\u00e9es \u00e0 partir d'un ensemble de donn\u00e9es d'entra\u00eenement. Les r\u00e9seaux de neurones g\u00e9n\u00e9ratifs sont utilis\u00e9s pour la g\u00e9n\u00e9ration de texte, d'images, de musique, etc.</p>"},{"location":"eval/","title":"Comment evaluer mon mod\u00e9le","text":""},{"location":"eval/#evaluation-dun-modele-de-regression","title":"\u00c9valuation d'un mod\u00e8le de r\u00e9gression","text":""},{"location":"eval/#les-coefficients-de-regression","title":"Les coefficients de r\u00e9gression","text":"<p>L'\u00e9quation d'une r\u00e9gression lin\u00e9aire simple peut \u00eatre \u00e9crite comme :</p> <pre><code>y = \u03b20 + \u03b21x + \u03b5\n</code></pre> <p>o\u00f9 :</p> <ul> <li>y est la variable d\u00e9pendante,</li> <li>x est la variable ind\u00e9pendante,</li> <li>\u03b20 est l'interception ou constante,</li> <li>\u03b21 est la pente ou coefficient de r\u00e9gression,</li> <li>\u03b5 est l'erreur r\u00e9siduelle.</li> </ul> <p>L'\u00e9quation indique que la valeur de y d\u00e9pend de la valeur de x multipli\u00e9e par le coefficient de r\u00e9gression \u03b21 et ajout\u00e9e \u00e0 l'interception \u03b20, avec une certaine erreur r\u00e9siduelle \u03b5. La r\u00e9gression lin\u00e9aire multiple peut \u00eatre \u00e9tendue pour inclure plusieurs variables ind\u00e9pendantes, ce qui donnerait une \u00e9quation de la forme :</p> <pre><code>y = \u03b20 + \u03b21x1 + \u03b22x2 + ... + \u03b2pxp + \u03b5\n</code></pre> <p>o\u00f9 p est le nombre de variables ind\u00e9pendantes.</p> <p></p> <p>Les coefficients de r\u00e9gression sont utilis\u00e9s pour mesurer la relation entre les variables ind\u00e9pendantes et la variable d\u00e9pendante dans un mod\u00e8le de r\u00e9gression. Un coefficient positif indique une relation positive entre les variables, tandis qu'un coefficient n\u00e9gatif indique une relation inverse. En r\u00e9gression lin\u00e9aire simple, le coefficient de pente mesure la variation de la variable d\u00e9pendante pour une unit\u00e9 de variation de la variable ind\u00e9pendante, tandis que le coefficient d'interception indique la valeur de la variable d\u00e9pendante lorsque la variable ind\u00e9pendante est \u00e9gale \u00e0 z\u00e9ro. Cependant, l'interpr\u00e9tation des coefficients d\u00e9pend du type de mod\u00e8le et de la nature des donn\u00e9es.</p>"},{"location":"eval/#mean-absolute-error-mae","title":"Mean Absolute Error (MAE)","text":"<p>La MAE mesure l'erreur absolue moyenne entre les pr\u00e9visions et les observations r\u00e9elles. Elle est calcul\u00e9e en faisant la somme des valeurs absolues des diff\u00e9rences entre chaque pr\u00e9diction et la valeur r\u00e9elle, puis en divisant cette somme par le nombre total de pr\u00e9dictions. Elle est souvent utilis\u00e9e pour des mod\u00e8les de r\u00e9gression simples, Plus le MAE est faible, meilleure est la performance du mod\u00e8le.</p> <p></p> <p>L'\u00e9quation de la MAE est la suivante :</p> <pre><code>MAE = (1/n) * \u03a3|i=1 \u00e0 n|(|y_i - \u0177_i|)\n\n</code></pre> <p>O\u00f9 :</p> <ul> <li>n : le nombre d'observations dans l'ensemble de donn\u00e9es de test</li> <li>y_i : la valeur r\u00e9elle de la variable cible pour la i-\u00e8me observation</li> <li>\u0177_i : la valeur pr\u00e9dite de la variable cible pour la i-\u00e8me observation</li> </ul> <p>Exemple de code Python pour calculer la MAE :</p> <pre><code>from sklearn.metrics import mean_absolute_error\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmae = mean_absolute_error(y_true, y_pred)\n\nprint(\"MAE: \", mae) #R\u00e9sultat : MAE: 0.5\n</code></pre>"},{"location":"eval/#mean-squared-error-mse","title":"Mean Squared Error (MSE)","text":"<p>La MSE mesure la moyenne des carr\u00e9s des erreurs entre les pr\u00e9visions et les observations r\u00e9elles. Elle est calcul\u00e9e en faisant la somme des carr\u00e9s des diff\u00e9rences entre chaque pr\u00e9diction et la valeur r\u00e9elle, puis en divisant cette somme par le nombre total de pr\u00e9dictions. Elle est souvent utilis\u00e9e pour des mod\u00e8les de r\u00e9gression plus complexes.  Il est plus sensible aux grandes erreurs que le MAE. Plus le MSE est faible, meilleure est la performance du mod\u00e8le.</p> <p></p> <p>L'\u00e9quation de la MSE est la suivante :</p> <pre><code>MSE = (1/n) * \u03a3|i=1 \u00e0 n|(y_i - \u0177_i)^2\n</code></pre> <p>O\u00f9 :</p> <ul> <li>n : le nombre d'observations dans l'ensemble de donn\u00e9es de test</li> <li>y_i : la valeur r\u00e9elle de la variable cible pour la i-\u00e8me observation</li> <li>\u0177_i : la valeur pr\u00e9dite de la variable cible pour la i-\u00e8me observation</li> </ul> <p>Exemple de code Python pour calculer la MSE :</p> <pre><code>from sklearn.metrics import mean_squared_error\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmse = mean_squared_error(y_true, y_pred)\n\nprint(\"MSE: \", mse) #R\u00e9sultat : MSE: 0.375\n\n</code></pre>"},{"location":"eval/#root-mean-squared-error-rmse","title":"Root Mean Squared Error (RMSE)","text":"<p>Le RMSE est la racine carr\u00e9e du MSE et repr\u00e9sente l'erreur moyenne entre les pr\u00e9dictions du mod\u00e8le et les valeurs r\u00e9elles de la variable cible. Il est souvent utilis\u00e9 pour des mod\u00e8les de r\u00e9gression plus complexes. Plus le RMSE est faible, meilleure est la performance du mod\u00e8le.</p> <p></p> <p>L'\u00e9quation du RMSE est la suivante :</p> <pre><code>RMSE = sqrt(MSE)\n</code></pre> <p>Exemple de code Python pour calculer le RMSE :</p> <pre><code>from sklearn.metrics import mean_squared_error\nimport numpy as np\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\nmse = mean_squared_error(y_true, y_pred)\nrmse = np.sqrt(mse)\n\nprint(\"RMSE: \", rmse) # R\u00e9sultat : RMSE: 0.6123724356957945\n</code></pre>"},{"location":"eval/#coefficient-de-determination-r2","title":"Coefficient de d\u00e9termination R\u00b2","text":"<p>Le coefficient de d\u00e9termination R\u00b2 mesure la proportion de variance expliqu\u00e9e par le mod\u00e8le. Il varie de 0 \u00e0 1, o\u00f9 0 signifie que le mod\u00e8le ne parvient pas \u00e0 expliquer la variance de la variable cible et 1 signifie qu'il explique toute la variance. Plus le R\u00b2 est \u00e9lev\u00e9, meilleure est la performance du mod\u00e8le. Equation : </p> <pre><code>R\u00b2 = 1 - SSE / SST\n</code></pre> <p>o\u00f9 SSE est la somme des carr\u00e9s des r\u00e9sidus (c'est-\u00e0-dire la somme des carr\u00e9s des diff\u00e9rences entre les valeurs pr\u00e9dites et les valeurs r\u00e9elles), et SST est la somme des carr\u00e9s des diff\u00e9rences entre les valeurs r\u00e9elles et la moyenne des valeurs r\u00e9elles.</p> <ul> <li>Somme des carr\u00e9s des erreurs (SSE) :</li> </ul> <pre><code>SSE = \u03a3(yi - \u0177i)\u00b2\n</code></pre> <p>o\u00f9 yi est la valeur r\u00e9elle de la variable d\u00e9pendante, et \u0177i est la valeur pr\u00e9dite par le mod\u00e8le.</p> <ul> <li>Somme totale des carr\u00e9s (SST) :</li> </ul> <pre><code>SST = \u03a3(yi - \u0233)\u00b2\n</code></pre> <p>o\u00f9 yi est la valeur r\u00e9elle de la variable d\u00e9pendante, et \u0233 est la moyenne des valeurs r\u00e9elles.</p> <pre><code>from sklearn.metrics import r2_score\n\ny_true = [3, -0.5, 2, 7]\ny_pred = [2.5, 0.0, 2, 8]\n\n# Calcul du coefficient de d\u00e9termination R\u00b2\nr2 = r2_score(y_train, y_pred)\n\nprint(\"Coefficient de d\u00e9termination R\u00b2 :\", r2)\n</code></pre>"},{"location":"eval/#interpretation-des-resultats","title":"Interpr\u00e9tation des r\u00e9sultats","text":"<ul> <li> <p>MAE : Un MAE de 0 signifie que le mod\u00e8le pr\u00e9dit parfaitement les valeurs de la variable cible. En g\u00e9n\u00e9ral, un MAE faible indique une bonne performance, mais cela d\u00e9pend du contexte et de la plage de valeurs de la variable cible.</p> </li> <li> <p>MSE et RMSE : Comme mentionn\u00e9 pr\u00e9c\u00e9demment, ces deux m\u00e9triques sont plus sensibles aux grandes erreurs que le MAE. Par cons\u00e9quent, un MSE ou un RMSE \u00e9lev\u00e9 peut indiquer qu'il y a des valeurs aberrantes dans les donn\u00e9es ou que le mod\u00e8le ne parvient pas \u00e0 pr\u00e9dire correctement les valeurs extr\u00eames de la variable cible.</p> </li> <li> <p>R\u00b2 : indique la proportion de la variance totale des donn\u00e9es qui est expliqu\u00e9e par le mod\u00e8le. Un R\u00b2 de 1 signifie que le mod\u00e8le explique parfaitement la variance des donn\u00e9es, tandis qu'un R\u00b2 de 0 signifie que le mod\u00e8le n'explique aucune variance des donn\u00e9es. Dans la pratique, un R\u00b2 \u00e9lev\u00e9 (g\u00e9n\u00e9ralement sup\u00e9rieur \u00e0 0,7 ou 0,8) est consid\u00e9r\u00e9 comme un bon ajustement du mod\u00e8le aux donn\u00e9es.</p> </li> <li> <p>SSE indique la quantit\u00e9 d'erreur r\u00e9siduelle dans le mod\u00e8le. En g\u00e9n\u00e9ral, plus SSE est faible, mieux c'est, car cela signifie que les pr\u00e9dictions du mod\u00e8le sont plus proches des valeurs r\u00e9elles.</p> </li> <li> <p>SST indique la quantit\u00e9 de variation totale dans les donn\u00e9es. Il est souvent utilis\u00e9 comme mesure de la variabilit\u00e9 des donn\u00e9es de r\u00e9f\u00e9rence. Un mod\u00e8le qui explique une grande partie de la variation totale de SST est consid\u00e9r\u00e9 comme un bon ajustement aux donn\u00e9es.</p> </li> </ul>"},{"location":"eval/#evaluation-dun-modele-de-classification","title":"\u00c9valuation d'un mod\u00e8le de classification","text":""},{"location":"eval/#accuracy","title":"Accuracy","text":"<p>L'accuracy est la m\u00e9trique la plus simple pour \u00e9valuer les mod\u00e8les de classification. Elle mesure la proportion de pr\u00e9dictions correctes sur l'ensemble de donn\u00e9es de test.</p> <p></p> <p>L'\u00e9quation de l'accuracy est la suivante :</p> <pre><code>Accuracy = (TP + TN) / (TP + TN + FP + FN)\n</code></pre> <p>O\u00f9 :</p> <ul> <li>TP : True Positives, le nombre de pr\u00e9dictions positives correctes</li> <li>TN : True Negatives, le nombre de pr\u00e9dictions n\u00e9gatives correctes</li> <li>FP : False Positives, le nombre de pr\u00e9dictions positives incorrectes</li> <li>FN : False Negatives, le nombre de pr\u00e9dictions n\u00e9gatives incorrectes</li> </ul> <p>Exemple de code Python pour calculer l'accuracy :</p> <pre><code>from sklearn.metrics import accuracy_score\n\ny_true = [0, 1, 2, 0, 1, 2]\ny_pred = [0, 2, 1, 0, 0, 1]\n\naccuracy = accuracy_score(y_true, y_pred)\n\nprint(\"Accuracy: \", accuracy) #R\u00e9sultat : Accuracy: 0.3333333333333333\n</code></pre>"},{"location":"eval/#precision-recall-et-f1-score","title":"Precision, Recall et F1-score","text":"<p>La pr\u00e9cision (precision), le rappel (recall) et le score F1 (F1-score) sont des m\u00e9triques plus avanc\u00e9es pour \u00e9valuer les mod\u00e8les de classification. Elles sont particuli\u00e8rement utiles pour les probl\u00e8mes de classification binaire, o\u00f9 l'on souhaite pr\u00e9dire la pr\u00e9sence ou l'absence d'une classe.</p> <ul> <li>La pr\u00e9cision mesure la proportion de pr\u00e9dictions positives qui sont correctes. Elle est calcul\u00e9e en divisant le nombre de vrais positifs par le nombre de vrais positifs plus le nombre de faux positifs.L'\u00e9quation de la pr\u00e9cision est la suivante :</li> </ul> <pre><code>Precision = TP / (TP + FP)\n</code></pre> <ul> <li>Le rappel mesure la proportion de vrais positifs qui sont correctement identifi\u00e9s. Il est calcul\u00e9 en divisant le nombre de vrais positifs par le nombre de vrais positifs plus le nombre de faux n\u00e9gatifs. L'\u00e9quation du rappel est la suivante :</li> </ul> <pre><code>Recall = TP / (TP + FN)\n</code></pre> <ul> <li>Le score F1 est une moyenne harmonique de la pr\u00e9cision et du rappel. Il est calcul\u00e9 en prenant la moyenne pond\u00e9r\u00e9e de la pr\u00e9cision et du rappel, o\u00f9 la pond\u00e9ration est donn\u00e9e par l'harmonique de la pr\u00e9cision et du rappel. L'\u00e9quation du score F1 est la suivante :</li> </ul> <pre><code>F1 = 2 * (Precision * Recall) / (Precision + Recall)\n</code></pre> <p>Exemple de code Python pour calculer la pr\u00e9cision, le rappel et le score F1 :</p> <pre><code>from sklearn.metrics import precision_score, recall_score, f1_score\n\ny_true = [0, 1, 2, 0, 1, 2]\ny_pred = [0, 2, 1, 0, 0, 1]\n\nprecision = precision_score(y_true, y_pred, average='macro')\nrecall = recall_score(y_true, y_pred, average='macro')\nf1 = f1_score(y_true, y_pred, average='macro')\n\nprint(\"Precision: \", precision)\nprint(\"Recall: \", recall)\nprint(\"F1-score: \", f1)\n\n</code></pre>"},{"location":"eval/#matrice-de-confusion","title":"Matrice de confusion","text":"<p>La matrice de confusion est un outil visuel pour \u00e9valuer les performances d'un mod\u00e8le de classification. Elle montre le nombre de pr\u00e9dictions correctes et incorrectes pour chaque classe.</p> <p></p> <p>Exemple de code Python pour afficher la matrice de confusion :</p> <pre><code>from sklearn.metrics import confusion_matrix\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ny_true = [0, 1, 2, 0, 1, 2]\ny_pred = [0, 2, 1, 0, 0, 1]\n\ncm = confusion_matrix(y_true, y_pred)\n\nsns.heatmap(cm, annot=True, cmap=\"Blues\")\nplt.xlabel('Pr\u00e9dictions')\nplt.ylabel('Valeurs r\u00e9elles')\nplt.show()\n\n</code></pre>"},{"location":"eval/#interpreter-les-metriques-devaluation-de-classification","title":"Interpr\u00e9ter les m\u00e9triques d'\u00e9valuation de classification:","text":"<p>Tout d\u00e9pend du contexte sp\u00e9cifique de chaque projet de machine learning. Cependant, voici quelques points g\u00e9n\u00e9raux \u00e0 prendre en compte lors de l'interpr\u00e9tation de ces m\u00e9triques :</p> <ul> <li> <p>Pr\u00e9cision : La pr\u00e9cision mesure le taux de pr\u00e9dictions positives correctes parmi toutes les pr\u00e9dictions positives. Par exemple, une pr\u00e9cision de 0,8 signifie que le mod\u00e8le a correctement pr\u00e9dit 80% des r\u00e9sultats positifs. Cependant, si la pr\u00e9cision est \u00e9lev\u00e9e mais que le rappel est faible, cela peut indiquer que le mod\u00e8le pr\u00e9dit trop peu de r\u00e9sultats positifs, manquant ainsi des r\u00e9sultats positifs r\u00e9els.</p> </li> <li> <p>Rappel : Le rappel mesure le taux de pr\u00e9dictions positives correctes parmi tous les r\u00e9sultats positifs r\u00e9els. Par exemple, un rappel de 0,7 signifie que le mod\u00e8le a correctement pr\u00e9dit 70% des r\u00e9sultats positifs. Cependant, si le rappel est \u00e9lev\u00e9 mais que la pr\u00e9cision est faible, cela peut indiquer que le mod\u00e8le pr\u00e9dit trop de r\u00e9sultats positifs, y compris des r\u00e9sultats faux positifs.</p> </li> <li> <p>Score F1 : Le score F1 est une moyenne harmonique de la pr\u00e9cision et du rappel. Il est g\u00e9n\u00e9ralement utilis\u00e9 lorsque l'on souhaite trouver un \u00e9quilibre entre la pr\u00e9cision et le rappel.</p> </li> <li> <p>Matrice de confusion : La matrice de confusion montre le nombre de pr\u00e9dictions correctes et incorrectes pour chaque classe. Elle permet de voir o\u00f9 le mod\u00e8le est en train de se tromper. Par exemple, si le mod\u00e8le pr\u00e9dit souvent la classe 0 alors qu'elle est r\u00e9ellement la classe 1, il peut y avoir une confusion entre ces deux classes.</p> </li> </ul> <p>En g\u00e9n\u00e9ral, il est important d'\u00e9valuer le mod\u00e8le avec plusieurs m\u00e9triques pour avoir une vue d'ensemble de ses performances. Selon le contexte, certaines m\u00e9triques peuvent \u00eatre plus importantes que d'autres. Par exemple, dans les probl\u00e8mes de d\u00e9tection de fraude, un rappel \u00e9lev\u00e9 peut \u00eatre plus important que la pr\u00e9cision, car il est crucial de ne pas manquer de cas de fraude, m\u00eame si cela signifie avoir plus de faux positifs.</p>"},{"location":"ml/","title":"Les taches et mod\u00e9les de ML","text":""},{"location":"ml/#on-fait-quoi-avec","title":"On fait quoi avec ?","text":"<p>Le machine learning peut \u00eatre utilis\u00e9 pour diff\u00e9rentes t\u00e2ches, selon le type de donn\u00e9es que vous avez et le probl\u00e8me que vous essayez de r\u00e9soudre. Voici un aper\u00e7u de quelques-unes des t\u00e2ches les plus courantes :</p> <ul> <li> <p>R\u00e9gression : la r\u00e9gression consiste \u00e0 pr\u00e9dire une valeur num\u00e9rique en fonction d'un ou plusieurs param\u00e8tres. Par exemple, vous pouvez utiliser la r\u00e9gression pour pr\u00e9dire le prix d'une maison en fonction de son emplacement, de sa taille et de ses caract\u00e9ristiques. </p> </li> <li> <p>Classification : la classification consiste \u00e0 pr\u00e9dire une \u00e9tiquette discr\u00e8te en fonction d'un ensemble de caract\u00e9ristiques. Par exemple, vous pouvez utiliser la classification pour pr\u00e9dire si un email est du spam ou non, en fonction de son contenu et de ses caract\u00e9ristiques.</p> </li> <li> <p>Clustering : le clustering consiste \u00e0 regrouper des points de donn\u00e9es similaires dans des groupes, sans \u00e9tiquettes de classe pr\u00e9d\u00e9finies. Par exemple, vous pouvez utiliser le clustering pour regrouper les clients de votre boutique en fonction de leurs habitudes d'achat.</p> </li> <li> <p>R\u00e9duction de dimension : la r\u00e9duction de dimension consiste \u00e0 r\u00e9duire la complexit\u00e9 des donn\u00e9es en r\u00e9duisant le nombre de variables ou de caract\u00e9ristiques. Par exemple, vous pouvez utiliser la r\u00e9duction de dimension pour visualiser des donn\u00e9es \u00e0 haute dimension en deux ou trois dimensions.</p> </li> </ul>"},{"location":"ml/#types-de-m-l","title":"Types de M L","text":"<p>Il existe deux types principaux :</p>"},{"location":"ml/#lapprentissage-supervise","title":"L'apprentissage supervis\u00e9","text":"<p>Dans ce type d'apprentissage, le mod\u00e8le apprend \u00e0 pr\u00e9dire une sortie \u00e0 partir d'une entr\u00e9e, en utilisant un ensemble de donn\u00e9es d'apprentissage qui contient des exemples d'entr\u00e9es et de sorties connues. Le mod\u00e8le ajuste ensuite ses param\u00e8tres pour minimiser l'erreur de pr\u00e9diction. </p> <p></p> <p>Voici quelques mod\u00e8les de machine learning supervis\u00e9s :</p>"},{"location":"ml/#regression-lineaire","title":"R\u00e9gression lin\u00e9aire","text":"<p>La r\u00e9gression lin\u00e9aire est une m\u00e9thode de pr\u00e9diction qui permet de mod\u00e9liser la relation entre une variable cible continue et une ou plusieurs variables pr\u00e9dictives continues ou cat\u00e9gorielles. Le but de la r\u00e9gression lin\u00e9aire est de trouver la meilleure droite (ou hyperplan en dimension sup\u00e9rieure) qui repr\u00e9sente la relation entre les variables. </p> <p></p> <p>Le mod\u00e8le peut \u00eatre utilis\u00e9 pour la pr\u00e9diction ou pour comprendre la relation entre les variables. Par exemple, dans le cas de la pr\u00e9diction de prix de vente d'une maison, les variables pr\u00e9dictives pourraient \u00eatre la superficie, le nombre de chambres, la localisation, etc.</p> <p></p> <p>Exemple de code :</p> <pre><code>from sklearn.linear_model import LinearRegression\n\n# Cr\u00e9ation d'un mod\u00e8le de r\u00e9gression lin\u00e9aire\nregression_model = LinearRegression()\n\n# Entra\u00eenement du mod\u00e8le sur les donn\u00e9es d'entra\u00eenement\nregression_model.fit(X_train, y_train)\n\n# Pr\u00e9diction des valeurs pour les donn\u00e9es de test\ny_pred = regression_model.predict(X_test)\n</code></pre>"},{"location":"ml/#regression-logistique","title":"R\u00e9gression logistique","text":"<p>La r\u00e9gression logistique est une m\u00e9thode de classification qui permet de pr\u00e9dire la probabilit\u00e9 qu'une observation appartienne \u00e0 une classe particuli\u00e8re (binaire ou multi-classes). La sortie est une probabilit\u00e9, donc la valeur pr\u00e9dite est toujours comprise entre 0 et 1. </p> <p></p> <p>Le mod\u00e8le estime la probabilit\u00e9 de l'appartenance \u00e0 chaque classe en fonction des variables pr\u00e9dictives. Le mod\u00e8le est souvent utilis\u00e9 pour la classification de clients potentiels, de mails comme spam ou non, etc.</p> <p></p> <p>Exemple de code :</p> <pre><code>from sklearn.linear_model import LogisticRegression\n\n# Cr\u00e9ation d'un mod\u00e8le de r\u00e9gression logistique\nlogistic_model = LogisticRegression()\n\n# Entra\u00eenement du mod\u00e8le sur les donn\u00e9es d'entra\u00eenement\nlogistic_model.fit(X_train, y_train)\n\n# Pr\u00e9diction des classes pour les donn\u00e9es de test\ny_pred = logistic_model.predict(X_test)\n</code></pre>"},{"location":"ml/#arbre-de-decision","title":"Arbre de d\u00e9cision","text":"<p>Les arbres de d\u00e9cision sont une m\u00e9thode de classification et de r\u00e9gression qui permettent de cr\u00e9er un mod\u00e8le \u00e0 partir des donn\u00e9es en formes d'arbre. Les noeuds internes de l'arbre repr\u00e9sentent une condition sur les variables pr\u00e9dictives, les feuilles de l'arbre repr\u00e9sentent les pr\u00e9dictions de la variable cible. Le mod\u00e8le est facilement interpr\u00e9table et permet de comprendre comment les variables sont utilis\u00e9es pour la pr\u00e9diction.</p> <p></p> <p>Exemple de code :</p> <pre><code>from sklearn.tree import DecisionTreeClassifier\n\n# Cr\u00e9ation d'un mod\u00e8le d'arbre de d\u00e9cision\ntree_model = DecisionTreeClassifier()\n\n# Entra\u00eenement du mod\u00e8le sur les donn\u00e9es d'entra\u00eenement\ntree_model.fit(X_train, y_train)\n\n# Pr\u00e9diction des classes pour les donn\u00e9es de test\ny_pred = tree_model.predict(X_test)\n</code></pre>"},{"location":"ml/#foret-darbres-decisionnels","title":"For\u00eat d'arbres d\u00e9cisionnels","text":"<p>Les for\u00eats d'arbres d\u00e9cisionnels sont une m\u00e9thode de classification et de r\u00e9gression qui combine les r\u00e9sultats de plusieurs arbres de d\u00e9cision. Chaque arbre dans la for\u00eat est entra\u00een\u00e9 sur un \u00e9chantillon al\u00e9atoire des donn\u00e9es d'entra\u00eenement. Le mod\u00e8le agr\u00e8ge les pr\u00e9dictions des diff\u00e9rents arbres pour donner une pr\u00e9diction finale. Les for\u00eats d'arbres d\u00e9cisionnels sont souvent plus pr\u00e9cises que les arbres de d\u00e9cision.</p> <p></p> <p>Voici un exemple de code utilisant Scikit-learn pour entra\u00eener un mod\u00e8le de for\u00eat al\u00e9atoire pour la classification :</p> <pre><code>from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.datasets import make_classification\n\nX, y = make_classification(n_features=4, random_state=0)\nclf = RandomForestClassifier(max_depth=2, random_state=0)\nclf.fit(X, y)\n</code></pre>"},{"location":"ml/#les-machines-a-vecteurs-de-support-svm","title":"Les Machines \u00e0 Vecteurs de Support (SVM)","text":"<p>Les SVM sont un algorithme d'apprentissage supervis\u00e9 utilis\u00e9 pour la classification et la r\u00e9gression. Les SVM trouvent une fronti\u00e8re de d\u00e9cision qui maximise la marge entre les deux classes. Cette fronti\u00e8re de d\u00e9cision est appel\u00e9e un hyperplan. Les SVM peuvent \u00eatre utilis\u00e9es pour des t\u00e2ches de classification avec deux classes ou plus.</p> <p></p> <p>Les SVM ont une grande pr\u00e9cision et sont populaires dans les t\u00e2ches de classification. Ils peuvent \u00e9galement \u00eatre utilis\u00e9s pour la r\u00e9gression.</p> <p></p> <p>Voici un exemple de code utilisant Scikit-learn pour entra\u00eener un mod\u00e8le SVM pour la classification :</p> <pre><code>from sklearn import svm\nfrom sklearn.datasets import make_classification\n\nX, y = make_classification(n_features=4, random_state=0)\nclf = svm.SVC(kernel='linear', C=1, random_state=0)\nclf.fit(X, y)\n</code></pre>"},{"location":"ml/#lapprentissage-non-supervise","title":"L'apprentissage non supervis\u00e9","text":"<p>Les mod\u00e8les non supervis\u00e9s sont des algorithmes de machine learning qui n'ont pas besoin de donn\u00e9es \u00e9tiquet\u00e9es pour fonctionner. Ils sont utilis\u00e9s pour explorer les donn\u00e9es et trouver des structures cach\u00e9es, des mod\u00e8les et des corr\u00e9lations. Voici quelques exemples de mod\u00e8les non supervis\u00e9s:</p>"},{"location":"ml/#k-means-clustering","title":"K-means clustering","text":"<p>Le K-means clustering est une technique de partitionnement de donn\u00e9es qui permet de diviser un ensemble de donn\u00e9es en K groupes distincts (clusters). Chaque point de donn\u00e9es est affect\u00e9 \u00e0 un cluster en fonction de sa proximit\u00e9 avec le centre de ce cluster.</p> <p></p> <p>Voici un exemple de code en Python pour appliquer le K-means clustering :</p> <pre><code>from sklearn.cluster import KMeans\nimport numpy as np\n\n# G\u00e9n\u00e9rer des donn\u00e9es al\u00e9atoires\nX = np.random.rand(100, 2)\n\n# Instancier le mod\u00e8le de clustering\nkmeans = KMeans(n_clusters=3)\n\n# Fitter le mod\u00e8le aux donn\u00e9es\nkmeans.fit(X)\n\n# Pr\u00e9dire les clusters pour de nouvelles donn\u00e9es\nlabels = kmeans.predict(X)\n</code></pre>"},{"location":"ml/#analyse-en-composantes-principales-pca","title":"Analyse en composantes principales (PCA)","text":"<p>L'analyse en composantes principales est une m\u00e9thode de r\u00e9duction de dimension qui permet de projeter des donn\u00e9es \u00e0 haute dimension sur un espace de dimension inf\u00e9rieure tout en conservant autant que possible les informations contenues dans les donn\u00e9es originales.</p> <p></p> <p>Voici un exemple de code en Python pour appliquer l'analyse en composantes principales :</p> <pre><code>from sklearn.decomposition import PCA\nimport numpy as np\n\n# G\u00e9n\u00e9rer des donn\u00e9es al\u00e9atoires\nX = np.random.rand(100, 10)\n\n# Instancier le mod\u00e8le de PCA\npca = PCA(n_components=3)\n\n# Fitter le mod\u00e8le aux donn\u00e9es\npca.fit(X)\n\n# Transformer les donn\u00e9es pour obtenir les nouvelles dimensions\nX_pca = pca.transform(X)\n</code></pre>"},{"location":"ml/#reduction-de-dimension-avec-t-sne","title":"R\u00e9duction de dimension avec t-SNE","text":"<p>t-SNE est une m\u00e9thode de r\u00e9duction de dimension qui permet de projeter des donn\u00e9es \u00e0 haute dimension sur un espace de dimension inf\u00e9rieure en conservant autant que possible les relations de proximit\u00e9 entre les donn\u00e9es.</p> <p></p> <p>Voici un exemple de code en Python pour appliquer la r\u00e9duction de dimension avec t-SNE :</p> <pre><code>from sklearn.manifold import TSNE\nimport numpy as np\n\n# G\u00e9n\u00e9rer des donn\u00e9es al\u00e9atoires\nX = np.random.rand(100, 10)\n\n# Instancier le mod\u00e8le de t-SNE\ntsne = TSNE(n_components=2)\n\n# Fitter le mod\u00e8le aux donn\u00e9es\nX_tsne = tsne.fit_transform(X)\n</code></pre>"},{"location":"numpy/","title":"NumPy","text":"<p>NumPy est l'abr\u00e9viation de Numerical Python. C'est une biblioth\u00e8que/package Python utilis\u00e9e pour travailler avec des tableaux qui contiennent des classes, des fonctions, des variables, une grande biblioth\u00e8que de fonctions math\u00e9matiques, etc. pour travailler avec des calculs scientifiques. Il peut \u00eatre utilis\u00e9 pour cr\u00e9er un tableau \"n\" dimensionnel o\u00f9 \"n\" est un entier quelconque.</p> <p>Pourquoi NumPy ? En Python, nous avons des listes qui servent de tableaux, mais elles sont lentes. NumPy vise \u00e0 fournir un objet de tableau qui est jusqu'\u00e0 50 fois plus rapide qu'une liste Python traditionnelle.</p> <p> L'objet de tableau dans NumPy s'appelle ndarray, il fournit de nombreuses fonctions de soutien qui rendent le travail avec ndarray tr\u00e8s facile. Les tableaux sont tr\u00e8s fr\u00e9quemment utilis\u00e9s en science des donn\u00e9es, o\u00f9 la vitesse et les ressources sont tr\u00e8s importantes.</p> <p> Ce qui rend les tableaux NumPy plus rapides que les listes : les tableaux NumPy sont stock\u00e9s \u00e0 un endroit continu en m\u00e9moire contrairement aux listes, de sorte que les processus peuvent y acc\u00e9der et les manipuler tr\u00e8s efficacement. Ce comportement est appel\u00e9 la localit\u00e9 de r\u00e9f\u00e9rence. C'est la principale raison pour laquelle NumPy est plus rapide que les listes. Il est \u00e9galement optimis\u00e9 pour fonctionner avec les derni\u00e8res architectures de processeur.</p> <p>Installation de NumPy Pour installer NumPy, vous pouvez utiliser pip, l'installateur de paquets Python. Ouvrez votre terminal ou votre invite de commande et entrez la commande suivante :</p> <p>Copy code pip3 install numpy Importation de NumPy Il existe deux fa\u00e7ons d'importer NumPy. Exemple de code :</p> <p>python Copy code</p>"},{"location":"numpy/#cela-importera-lensemble-du-module-numpy","title":"cela importera l'ensemble du module NumPy.","text":"<p>import numpy as np</p>"},{"location":"numpy/#cela-importera-toutes-les-classes-les-objets-les-variables-etc-du-package-numpy","title":"cela importera toutes les classes, les objets, les variables, etc. du package NumPy","text":"<p>from numpy import* NumPy est g\u00e9n\u00e9ralement import\u00e9 sous l'alias np.</p> <p> alias : en Python, les alias sont un nom alternatif pour faire r\u00e9f\u00e9rence \u00e0 la m\u00eame chose.</p> <p> Cr\u00e9ation de tableaux NumPy L'objet de tableau dans NumPy s'appelle ndarray. Nous pouvons cr\u00e9er un objet ndarray NumPy en utilisant la fonction array(). Les tableaux NumPy peuvent \u00eatre cr\u00e9\u00e9s de plusieurs mani\u00e8res. Voici quelques-unes des m\u00e9thodes les plus courantes :</p> <p>Utilisation de la fonction numpy.array() pour cr\u00e9er un tableau \u00e0 partir d'une liste/d'un tuple : css Copy code a = np.array([1, 2, 3]) Utilisation de la fonction numpy.zeros() pour cr\u00e9er un tableau rempli de z\u00e9ros : bash Copy code b = np.zeros((2, 3)) Utilisation de la fonction numpy.ones() pour cr\u00e9er un tableau rempli de uns : bash Copy code c = np.ones((2, 3)) Utilisation de la fonction numpy.random.randint() : renvoie un tableau d'entiers al\u00e9atoires entre les deux nombres donn\u00e9s. lua Copy code d = np.random.randint(0, 10) Utilisation de la fonction numpy.random.rand() pour cr\u00e9er un tableau de valeurs al\u00e9atoires : lua Copy code e = np.random.rand(2, 3) Dimensions des tableaux NumPy</p>"},{"location":"pd/","title":"Pd","text":"<p>pd</p>"}]}